% Hess4MLE
% compute Hessian around the MLE fit for each Data conditions

%% load Data and MLE fits
% load data files
datas = {'/projects/LEIFER/Kevin/Data_odor_opto/odor_opto_learn_data/Data_opto_app.mat',...
         '/projects/LEIFER/Kevin/Data_odor_opto/odor_opto_learn_data/Data_opto_nai.mat',...
         '/projects/LEIFER/Kevin/Data_odor_opto/odor_opto_learn_data/Data_opto_ave.mat'};
% load('/projects/LEIFER/Kevin/Data_learn/N2/data_analysis/Kfold_mle_param3.mat');
% %%% load mle_params_opt here...  %%%%% this is saved in a condition x parameter (3 x 13) matrix...

%%
MLE_std = zeros(3,13);  % three conditions and 13 parameters
dx = 0.1;

for ii = 1:3
    load(datas{ii})  % load Data
%     mlee = squeeze((mle_params_opto(ii,:)))';  % load the fitted MLE as x0
    mlee = squeeze(mean(mle_params(ii,:,:),2))';
    [H, g] = compHess(@pop_nLL_opto, mlee', dx, Data)

% Compute the inverse of the Hessian matrix
H_inv = inv(H);
% Extract the diagonal elements of the inverse Hessian matrix
variances = diag(H_inv);
% Compute the standard errors by taking the square root of the variances
standard_errors = sqrt(variances);

MLE_std(ii,:) = real(standard_errors)';

end

%%
figure
plot(MLE_std','-o')

%%
%% some post analysis for variability!
% for Kc kernel
ttl = {'appetitive','naive','aversive'};
col = {'b','k','r'};
[cosBasis, tgrid, basisPeaks] = makeRaisedCosBasis(4, [0, 8], 1.3);
tt = [1:length(cosBasis)]*5/14;
K = size(mle_params,1);
figure
for cc = 1:3
    subplot(1,3,cc);
    mlee = squeeze((mle_params_opto(ii,:)));
    y_odor = mlee(3:6)'*cosBasis';
    y_opto = mlee(7:10)'*cosBasis';
    mle_hess_odor = MLE_std(3:6);   % odor
    mle_hess_opto = MLE_std(7:10);  % opto
    
    standardError_odor = mle_hess_odor*cosBasis';
    plot(tt,y_odor,col{cc},'LineWidth',3)
    hold on
    % Create the shaded area
    xArea = [tt, fliplr(tt)];
    yArea = [y_odor + standardError_odor, fliplr(y_odor - standardError_odor)];
    fill(xArea, yArea, 'k', 'FaceAlpha', 0.3, 'EdgeColor', 'none');
    
    standardError_opto = mle_hess_opto*cosBasis';
    plot(tt,y_opto,col{cc},'LineWidth',3, '--')
    hold on
    % Create the shaded area
    xArea = [tt, fliplr(tt)];
    yArea = [y_opto + standardError_opto, fliplr(y_opto - standardError_opto)];
    fill(xArea, yArea, 'k', 'FaceAlpha', 0.3, 'EdgeColor', 'none');

    title(ttl{cc})
end

%% 
% for Kc_perp kernel
ttl = {'appetitive','naive','aversive'};
col = {'b','k','r'};
tt = [1:length(cosBasis)]*5/14;
figure
for cc = 1:3
    subplot(1,3,cc);
    mlee = squeeze(mean(mle_params(:,cc,:)));
    y = -mlee(8).*exp(-tt./mlee(9));
    mle_hess = MLE_std(8:9)/sqrt(length(Data));
    standardError = -mle_hess(1).*exp(-tt./mle_hess(2));
    plot(tt,y,col{cc},'LineWidth',3)
    hold on
    
    % Create the shaded area
    xArea = [tt, fliplr(tt)];
    yArea = [y + standardError, fliplr(y - standardError)];
    fill(xArea, yArea, 'k', 'FaceAlpha', 0.3, 'EdgeColor', 'none');

    title(ttl{cc})
end

%%
figure
xx = [1,2,3];
param_id = 1;  % the element for plot
for cc = 1:3
    base = squeeze(mean(mle_params(:,cc,param_id)));
    bar(xx(cc), base)
    hold on
%     berr = squeeze(std(mle_params(:,cc,param_id)));
    berr = MLE_std(cc,param_id);%/sqrt(length(Data));
    errorbar(xx(cc),base,berr)
end